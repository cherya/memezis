// Code generated by protoc-gen-goclay, but your can (must) modify it.
// source: memezis.proto

package memezis

import (
	"context"
	"sort"

	"github.com/cherya/memezis/internal/app/hfind"
	"github.com/cherya/memezis/internal/app/store"
	desc "github.com/cherya/memezis/pkg/memezis"

	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
)

type Duplicates struct {
	Complete []*desc.Post
	Likely   []*desc.Post
}

func (i *Memezis) FindDuplicates(ctx context.Context, req *desc.FindDuplicatesRequest) (*desc.FindDuplicatesResponse, error) {
	if req.GetId() == 0 {
		return nil, errors.New("FindDuplicates: id must be greater than 0")
	}

	media, err := i.store.GetMediaByIDs(ctx, []int64{req.GetId()})
	if err != nil {
		return nil, errors.Wrap(err, "can't get media by ids")
	}

	duplicates, err := i.findDuplicates(ctx, media[0])
	if err != nil {
		return nil, errors.Wrap(err, "error finding media duplicates")
	}

	return &desc.FindDuplicatesResponse{
		Complete: duplicates.Complete,
		Likely:   duplicates.Likely,
	}, nil
}

func (i *Memezis) findDuplicates(ctx context.Context, media store.Media) (*Duplicates, error) {
	hash, err := hfind.FromString(media.Phash)
	if err != nil {
		return nil, errors.Wrapf(err, "can't get convert hash from string %s", media.Phash)
	}
	matches := i.hstore.FindKNN(hash, 20)
	sort.Sort(matches)
	hashes := struct {
		Complete []string
		Likely   []string
	}{}

	for _, m := range matches {
		if m.Score == 0 {
			hashes.Complete = append(hashes.Complete, m.Hash.String())
		} else if m.Score < 7 {
			hashes.Likely = append(hashes.Likely, m.Hash.String())
		}
	}

	//TODO: must be one query
	complete, err := i.store.GetPostsByMediaHashes(ctx, hashes.Complete)
	if err != nil {
		complete = make([]store.Post, 0)
		log.Error(errors.Wrap(err, "findDuplicates: can't get posts by hashes (complete)"))
	}
	likely, err := i.store.GetPostsByMediaHashes(ctx, hashes.Likely)
	if err != nil {
		likely = make([]store.Post, 0)
		log.Error(errors.Wrap(err, "findDuplicates: can't get posts by hashes (likely)"))
	}

	duplicates := &Duplicates{
		Complete: make([]*desc.Post, 0),
		Likely:   make([]*desc.Post, 0),
	}

	for _, d := range complete {
		// exclude post which media belongs
		if media.PostID != d.ID {
			duplicates.Complete = append(duplicates.Complete, toProtoPost(&d, nil, i.fs.GetObjAbsoluteURL))
		}
	}
	for _, d := range likely {
		// exclude post which media belongs
		if media.PostID != d.ID {
			duplicates.Likely = append(duplicates.Likely, toProtoPost(&d, nil, i.fs.GetObjAbsoluteURL))
		}
	}

	return duplicates, nil
}
